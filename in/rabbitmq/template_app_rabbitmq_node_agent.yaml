templates:
  - name: Template App RabbitMQ Node by Zabbix agent
    _zbx_ver: '4.2'
    _classes:
      - APP
    description: |-
      Get node metrics from RabbitMQ management plugin provided an HTTP-based API using Zabbix agent.

    _documentation: 
      _tested_on:
      - name: RabbitMQ
        version: 3.5.7, 3.7.17, 3.7.18

      _overview: |+
        The template to monitor RabbitMQ by Zabbix that work without any external scripts.
        Most of the metrics are collected in one go, thanks to Zabbix bulk data collection.

        Template App RabbitMQ Node — (Zabbix version >= 4.2) collects metrics by polling [RabbitMQ management plugin](https://www.rabbitmq.com/management.html) locally with Zabbix agent.
        
        It also uses Zabbix agent to collect `RabbitMQ` Linux process stats like CPU usage, memory usage and whether process is running or not.

      _setup: |
        Enable the RabbitMQ management plugin. See [RabbitMQ’s documentation](https://www.rabbitmq.com/management.html) to enable it.

        Create a user to monitor the service:
        
        ```bash
        rabbitmqctl add_user zbx_monitor <PASSWORD>
        rabbitmqctl set_permissions  -p / zbx_monitor "" "" ".*"
        rabbitmqctl set_user_tags zbx_monitor monitoring
        ```
        
        Login and password are also set in macros:

        - {$RABBITMQ.API.USER}
        - {$RABBITMQ.API.PASSWORD}

        If you use another API endpoint, then don't forget to change `{$RABBITMQ.API.ENDPOINT}` macro.
        Install and setup [Zabbix agent](https://www.zabbix.com/documentation/current/manual/installation/install_from_packages).

      _zabbix_forum_url: forum url

    items:
      - _prototype: rabbitmq.overview
        type: ZABBIX_PASSIVE
        key: web.page.get["http://{$RABBITMQ.API.USER}:{$RABBITMQ.API.PASSWORD}@{$RABBITMQ.API.HOST}:{$RABBITMQ.API.PORT}/api/overview"]
        delay: 1m
        preprocessing:
          - type: REGEX
            params: "\\n\\s?\\n(.*)\n\\1"

      - _prototype: rabbitmq.nodes
        type: ZABBIX_PASSIVE
        key: web.page.get["http://{$RABBITMQ.API.USER}:{$RABBITMQ.API.PASSWORD}@{$RABBITMQ.API.HOST}:{$RABBITMQ.API.PORT}/api/nodes/{$RABBITMQ.CLUSTER.NAME}@{HOST.NAME}?memory=true"]
        delay: 1m
        preprocessing:
          - type: REGEX
            params: "\\n\\s?\\n(.*)\n\\1"

      - _prototype: rabbitmq.queues
        type: ZABBIX_PASSIVE
        key: web.page.get["http://{$RABBITMQ.API.USER}:{$RABBITMQ.API.PASSWORD}@{$RABBITMQ.API.HOST}:{$RABBITMQ.API.PORT}/api/queues"]
        delay: 1m
        preprocessing:
          - type: REGEX
            params: "\\n\\s?\\n(.*)\n\\1"

      - _prototype: rabbitmq.healthcheck
        type: ZABBIX_PASSIVE
        key: web.page.get["http://{$RABBITMQ.API.USER}:{$RABBITMQ.API.PASSWORD}@{$RABBITMQ.API.HOST}:{$RABBITMQ.API.PORT}/api/healthchecks/node"]
        delay: 1m
        value_map: RabbitMQ healthcheck
        preprocessing:
          - type: REGEX
            params: "\\n\\s?\\n(.*)\n\\1"
          - type: JSONPATH
            params: "$.status"
          - type: BOOL_TO_DECIMAL
            error_handler: CUSTOM_VALUE
            error_handler_params: 0

      - _prototype: rabbitmq.overview.management_version
      - _prototype: rabbitmq.overview.rabbitmq_version

      - _prototype: rabbitmq.node.fd_used
      - _prototype: rabbitmq.node.disk_free
      - _prototype: rabbitmq.node.mem_used
      - _prototype: rabbitmq.node.mem_limit
      - _prototype: rabbitmq.node.disk_free_limit
      - _prototype: rabbitmq.node.run_queue
      - _prototype: rabbitmq.node.sockets_used
      - _prototype: rabbitmq.node.sockets_total
      - _prototype: rabbitmq.node.partitions
      - _prototype: rabbitmq.node.running
        value_map: Service state
      - _prototype: rabbitmq.node.mem_alarm
      - _prototype: rabbitmq.node.disk_free_alarm
      - _prototype: rabbitmq.node.uptime

      - _id: rabbitmq.proc.num
        _prototype: proc.num
        key: proc.num["{$RABBITMQ.PROCESS_NAME}"]
        _group: RabbitMQ
        _resource: RabbitMQ

      - _id: rabbitmq.proc.mem.rss
        _prototype: proc.mem.rss
        key: proc.mem["{$RABBITMQ.PROCESS_NAME}",,,,rss]
        _group: RabbitMQ
        _resource: RabbitMQ

      - _id: rabbitmq.proc.mem.vsize
        _prototype: proc.mem.vsize
        key: proc.mem["{$RABBITMQ.PROCESS_NAME}",,,,vsize]
        _group: RabbitMQ
        _resource: RabbitMQ

      - _id: rabbitmq.proc.cpu.util
        _prototype: proc.cpu.util
        key: proc.cpu.util["{$RABBITMQ.PROCESS_NAME}"]
        _group: RabbitMQ
        _resource: RabbitMQ

      - _id: service.ping
        name: Service ping
        type: ZABBIX_PASSIVE
        key: net.tcp.service[http,"{$RABBITMQ.API.HOST}","{$RABBITMQ.API.PORT}"]
        value_type: UNSIGNED
        delay: 1m
        value_map: Service state
        history: 7d
        _group: RabbitMQ
        _resource: RabbitMQ
        preprocessing:
        - type: DISCARD_UNCHANGED_HEARTBEAT
          params: "10m"
        triggers:
        - _id: trigger.status
          name: Service is down
          expression: '{TEMPLATE_NAME:METRIC.last()}=0'
          manual_close: 'YES'
          priority: AVERAGE
          _depends_on:
          - trigger.proc.not_running

      - _id: service.perf
        name: Service response time
        type: ZABBIX_PASSIVE
        key: net.tcp.service.perf[http,"{$RABBITMQ.API.HOST}","{$RABBITMQ.API.PORT}"]
        value_type: FLOAT
        units: s
        delay: 1m
        history: 7d
        _group: RabbitMQ
        _resource: RabbitMQ
        triggers:
        - _id: trigger.perf.low
          name: Service response time is too high (over {$RABBITMQ.RESPONSE_TIME.MAX.WARN}s for 5m)
          expression: '{TEMPLATE_NAME:METRIC.min(5m)}>{$RABBITMQ.RESPONSE_TIME.MAX.WARN}'
          manual_close: 'YES'
          priority: WARNING
          _depends_on:
          - trigger.proc.not_running
          - trigger.status

    discovery_rules:
      - name: Queues discovery
        description: |
          Individual queue metrics

        key: rabbitmq.queues.discovery
        type: DEPENDENT
        masterItem: rabbitmq.queues

        lld_macro_paths:
          - lld_macro: "{#QUEUE}"
            path: "$.name"
          - lld_macro: "{#VHOST}"
            path: "$.vhost"
          - lld_macro: "{#NODE}"
            path: "$.node"

        filter:
          evalType: "AND"
          conditions:
            - macro: "{#QUEUE}"
              value: "{$RABBITMQ.LLD.FILTER.QUEUE.MATCHES}"
              operator: "MATCHES_REGEX"
              formulaid: "A"

            - macro: "{#QUEUE}"
              value: "{$RABBITMQ.LLD.FILTER.QUEUE.NOT_MATCHES}"
              operator: "NOT_MATCHES_REGEX"
              formulaid: "B"

            - macro: "{#NODE}"
              value: "{$RABBITMQ.CLUSTER.NAME}@{HOST.NAME}"
              operator: "MATCHES_REGEX"
              formulaid: "C"

        items:
        - _prototype: rabbitmq.queue.messages
        - _prototype: rabbitmq.queue.messages.rate
        - _prototype: rabbitmq.queue.consumers
        - _prototype: rabbitmq.queue.memory
        - _prototype: rabbitmq.queue.messages_ready
        - _prototype: rabbitmq.queue.messages_ready.rate
        - _prototype: rabbitmq.queue.messages_unacknowledged
        - _prototype: rabbitmq.queue.messages_unacknowledged.rate

        - _prototype: rabbitmq.queue.messages.ack
        - _prototype: rabbitmq.queue.messages.ack.rate
        - _prototype: rabbitmq.queue.messages.deliver
        - _prototype: rabbitmq.queue.messages.deliver.rate
        - _prototype: rabbitmq.queue.messages.deliver_get
        - _prototype: rabbitmq.queue.messages.deliver_get.rate
        - _prototype: rabbitmq.queue.messages.publish
        - _prototype: rabbitmq.queue.messages.publish.rate
        - _prototype: rabbitmq.queue.messages.redeliver
        - _prototype: rabbitmq.queue.messages.redeliver.rate


    macros:
      - macro: '{$RABBITMQ.API.USER}'
        value: zbx_monitor
      - macro: '{$RABBITMQ.API.PASSWORD}'
        value: zabbix

      - macro: '{$RABBITMQ.CLUSTER.NAME}'
        value: 'rabbit'
        _description: The name of RabbitMQ cluster

      - macro: '{$RABBITMQ.API.PORT}'
        value: 15672
        _description: The port of RabbitMQ API endpoint

      - macro: '{$RABBITMQ.API.HOST}'
        value: '127.0.0.1'
        _description: The hostname or IP of RabbitMQ API endpoint

      - macro: '{$RABBITMQ.PROCESS_NAME}'
        value: 'beam.smp'
        _description: RabbitMQ server process name

      - macro: '{$RABBITMQ.LLD.FILTER.QUEUE.MATCHES}'
        value: '.*'
        _description: Filter of discoverable queues

      - macro: '{$RABBITMQ.LLD.FILTER.QUEUE.NOT_MATCHES}'
        value: 'CHANGE_IF_NEEDED'
        _description: Filter to exclude discovered queues

      - macro: '{$RABBITMQ.RESPONSE_TIME.MAX.WARN}'
        value: 10
        _description: Maximum RabbitMQ response time in seconds for trigger expression

      - macro: '{$RABBITMQ.MESSAGES.MAX.WARN}'
        value: 1000
        _description: Maximum number of messages in the queue for trigger expression

    screens:
      - name: RabbitMQ node status
        hsize: 2
        vsize: 3
        screen_items:
        - _graph_id: rabbitmq.node.running
          x: 0
          y: 0
        - _graph_id: rabbitmq.node.uptime
          x: 1
          y: 0
        - _graph_id: rabbitmq.node.disk_free
          x: 0
          y: 1
        - _graph_id: rabbitmq.node.mem_used
          x: 1
          y: 1
        - _graph_id: rabbitmq.node.fd_used
          x: 0
          y: 2
        - _graph_id: rabbitmq.node.sockets
          x: 1
          y: 2

value_maps:
  - name: RabbitMQ healthcheck
    mappings:
    - value: 0
      newvalue: Failed
    - value: 1
      newvalue: Ok

  - name: Service state
    mappings:
    - value: 0
      newvalue: Down
    - value: 1
      newvalue: Up